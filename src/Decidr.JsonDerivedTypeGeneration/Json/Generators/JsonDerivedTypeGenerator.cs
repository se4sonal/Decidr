using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

// Coockbook
// https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.cookbook.md
// 

namespace Decidr.Json.Generators;

[Generator]
public class JsonDerivedTypeInterfaceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Get IJsonDerivedTypeBase symbol
        var markerInterfaceProvider = context.CompilationProvider
            .Select((compilation, _) =>
            {
                var attrType = typeof(IGenerateJsonDerivedType);
                var metadataName = attrType.FullName;
                return compilation.GetTypeByMetadataName(metadataName!);
            });

        // 2. Find all interfaces that inherit from IJsonDerivedTypeBase
        var baseInterfaces = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is InterfaceDeclarationSyntax,
                transform: static (ctx, _) =>
                {
                    var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) as INamedTypeSymbol;
                    return symbol;
                })
            .Where(static s => s is not null)
            .Combine(markerInterfaceProvider)
            .Where(pair => pair.Right != null)
            .Where(pair => InheritsFromInterface(pair.Left!, pair.Right!))
            .Select(static (pair, _) => pair.Left!)
            .Collect();

        // 3. Find all named types (classes/records) that implement any of these interfaces
        var allTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: static (ctx, _) =>
                    ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) as INamedTypeSymbol)
            .Where(s => s != null)
            .Select(static (s, _) => s!)
            .Collect();

        // 4. Combine base interfaces and all types
        var combined = baseInterfaces.Combine(allTypes);

        // 5. Generate source
        context.RegisterSourceOutput(combined, (spc, pair) =>
        {
            var baseInterfacesList = pair.Left;
            var allTypesList = pair.Right;

            foreach (var baseInterface in baseInterfacesList)
            {
                var derivedTypes = allTypesList
                    .Where(t => ImplementsInterface(t, baseInterface))
                    .ToImmutableArray();

                if (derivedTypes.Length == 0)
                    continue;

                var ns = baseInterface.ContainingNamespace?.ToDisplayString() ?? string.Empty;
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine("using System.Text.Json.Serialization;");
                if (!string.IsNullOrWhiteSpace(ns))
                {
                    sb.AppendLine();
                    sb.AppendLine($"namespace {ns};");
                }
                sb.AppendLine();

                // Add attributes for each derived type
                foreach (var d in derivedTypes)
                {
                    //var typeName = derived.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    //sb.AppendLine($"[JsonDerivedType(typeof({typeName}))]");

                    // Look for the JsonDerivedTypeNameAttribute
                    var nameAttr = d.GetAttributes()
                        .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() ==
                                             typeof(JsonDerivedTypeNameAttribute).FullName);

                    var typeName = d.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    if (nameAttr is not null && nameAttr.ConstructorArguments.Length == 1)
                    {
                        var specifiedName = nameAttr.ConstructorArguments[0].Value as string;
                        sb.AppendLine($"[JsonDerivedType(typeof({typeName}), \"{specifiedName}\")]");
                    }
                    else
                    {
                        sb.AppendLine($"[JsonDerivedType(typeof({typeName}))]");
                    }
                }

                // Generate partial interface code
                sb.AppendLine($"public partial interface {baseInterface.Name}");
                sb.AppendLine("{");
                sb.AppendLine("}");

                spc.AddSource($"{baseInterface.Name}.JsonDerivedTypes.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        });
    }

    private static bool InheritsFromInterface(INamedTypeSymbol candidate, INamedTypeSymbol baseInterface)
    {
        if (candidate.TypeKind != TypeKind.Interface)
            return false;

        return candidate.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, baseInterface));
    }

    private static bool ImplementsInterface(INamedTypeSymbol candidate, INamedTypeSymbol interfaceSymbol)
    {
        if (candidate.TypeKind == TypeKind.Interface)
        {
            return candidate.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, interfaceSymbol));
        }
        else
        {
            return candidate.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, interfaceSymbol));
        }
    }
}

